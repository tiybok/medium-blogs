<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Ansible Role to Configure K8S Multi- Node Cluster over AWS Cloud</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Ansible Role to Configure K8S Multi- Node Cluster over AWS Cloud</h1>
</header>
<section data-field="subtitle" class="p-summary">
Ansible Role to Configure K8S Multi Node Cluster over AWS Cloud
</section>
<section data-field="body" class="e-content">
<section name="f651" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="05f6" id="05f6" class="graf graf--h3 graf--leading graf--title">Ansible Role to Configure K8S Multi- Node Cluster over AWS Cloud</h3><p name="f212" id="f212" class="graf graf--p graf-after--h3">Ansible Role to Configure K8S Multi Node Cluster over AWS Cloud</p><figure name="a421" id="a421" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*vhik0HgBexQ-qPe3.png" data-width="1200" data-height="561" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*vhik0HgBexQ-qPe3.png"></figure><p name="effb" id="effb" class="graf graf--p graf-after--figure">As we know <strong class="markup--strong markup--p-strong">containers</strong> are a good way to bundle and run <strong class="markup--strong markup--p-strong">applications</strong>. But in the <strong class="markup--strong markup--p-strong">production</strong> environment, we need to manage the containers that run the application and ensure that there no downtime. For example, if a container goes down, another container needs to start. So here the role of <strong class="markup--strong markup--p-strong">Kubernetes</strong> comes into play. It provides a framework to run distributed system. It also takes care of <strong class="markup--strong markup--p-strong">scaling</strong> and <strong class="markup--strong markup--p-strong">failover</strong> of the application, provides <strong class="markup--strong markup--p-strong">deployment patterns</strong>, and more.</p><h3 name="a1fe" id="a1fe" class="graf graf--h3 graf-after--p">Kubernetes Cluster</h3><p name="efc2" id="efc2" class="graf graf--p graf-after--h3">A <strong class="markup--strong markup--p-strong">Kubernetes cluster</strong> is a set of nodes that runs containerized applications. Kubernetes cluster allows the application to run across multiple machines and environments: virtual, physical, cloud-based, and on-premises. <strong class="markup--strong markup--p-strong">Kubernetes clusters</strong> are not restricted to a specific operating system, unlike virtual machines. Instead, they can share operating systems and run anywhere.</p><figure name="a3fb" id="a3fb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*iu_aJBGvWrUtZWSZPyw6vw.png" data-width="1422" data-height="888" src="https://cdn-images-1.medium.com/max/800/1*iu_aJBGvWrUtZWSZPyw6vw.png"></figure><p name="a086" id="a086" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Kubernetes clusters</strong> are comprised of one <strong class="markup--strong markup--p-strong">master node</strong> and several <strong class="markup--strong markup--p-strong">worker nodes</strong>. These nodes can be physical computers or virtual machines, depending on the cluster.</p><p name="d541" id="d541" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">master node</strong> controls the state of the cluster, for example, which applications are running and their corresponding container images. The master node is the one that assigns tasks to the worker node.</p><p name="a88a" id="a88a" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">worker nodes</strong> are the components that run these applications. Worker nodes perform tasks assigned by the master node. They can either be virtual machines or physical computers.</p><p name="5917" id="5917" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Configuring</strong> the Kubernetes cluster manually is a tedious task and also consumes lots of time. And today is the world of <strong class="markup--strong markup--p-strong">automation</strong>, every company wants to automate its task. So in this article, I am going to explain how we can create an <strong class="markup--strong markup--p-strong">Ansible Role</strong> to automate the configuration of the <strong class="markup--strong markup--p-strong">Kubernetes cluster</strong> on <strong class="markup--strong markup--p-strong">AWS EC2 instances</strong>.</p><div name="ddd8" id="ddd8" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://tiybok45.medium.com/kubernetes-building-deploying-and-scaling-modern-applications-in-the-cloud-aa809168e6e2" data-href="https://tiybok45.medium.com/kubernetes-building-deploying-and-scaling-modern-applications-in-the-cloud-aa809168e6e2" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://tiybok45.medium.com/kubernetes-building-deploying-and-scaling-modern-applications-in-the-cloud-aa809168e6e2"><strong class="markup--strong markup--mixtapeEmbed-strong">Kubernetes : Building, Deploying and Scaling Modern Applications in the Cloud</strong><br><em class="markup--em markup--mixtapeEmbed-em">Industry Used Case on Kubernetes : CERN[European Council for Nuclear Research]</em>tiybok45.medium.com</a><a href="https://tiybok45.medium.com/kubernetes-building-deploying-and-scaling-modern-applications-in-the-cloud-aa809168e6e2" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="951ea90cf06b37a398dc540b0b30900e" data-thumbnail-img-id="1*toj5jm9x7yRELcktBhnr9g.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*toj5jm9x7yRELcktBhnr9g.png);"></a></div><h3 name="c9a6" id="c9a6" class="graf graf--h3 graf-after--mixtapeEmbed">TASK :</h3><ul class="postList"><li name="42b3" id="42b3" class="graf graf--li graf-after--h3">Ansible Role to Configure K8S Multi Node Cluster over AWS Cloud.</li><li name="22dc" id="22dc" class="graf graf--li graf-after--li">Create Ansible Playbook to launch 3 AWS EC2 Instance</li><li name="fa85" id="fa85" class="graf graf--li graf-after--li">Create Ansible Playbook to configure Docker over those instances.</li><li name="47c4" id="47c4" class="graf graf--li graf-after--li">Create Playbook to configure K8S Master, K8S Worker Nodes on the above created EC2 Instances using kubeadm.</li><li name="4660" id="4660" class="graf graf--li graf-after--li">Convert Playbook into roles and Upload those role on your Ansible Galaxy.</li><li name="e5a6" id="e5a6" class="graf graf--li graf-after--li">Also Upload all the YAML code over your GitHub Repository.</li><li name="b8e6" id="b8e6" class="graf graf--li graf-after--li">Create a README.md document using markdown language describing your Task in creative manner.</li></ul><p name="c084" id="c084" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Pre-requisites:</strong></p><ul class="postList"><li name="73b7" id="73b7" class="graf graf--li graf-after--p">Ansible should be installed on the Managed node.</li></ul><p name="1087" id="1087" class="graf graf--p graf-after--li">If you a new to ansible playbook please follow below example for better understanding of ansible playbook</p><div name="e3e5" id="e3e5" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://tiybok45.medium.com/configuration-of-apache-web-server-in-docker-container-using-ansible-playbook-2157c2d1358b" data-href="https://tiybok45.medium.com/configuration-of-apache-web-server-in-docker-container-using-ansible-playbook-2157c2d1358b" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://tiybok45.medium.com/configuration-of-apache-web-server-in-docker-container-using-ansible-playbook-2157c2d1358b"><strong class="markup--strong markup--mixtapeEmbed-strong"><em class="markup--em markup--mixtapeEmbed-em">Configuration of Apache Web-Server in Docker Container using Ansible Playbook</em></strong><br>Configuration of Apache Web-Server in Docker Container using Ansible Playbooktiybok45.medium.com</a><a href="https://tiybok45.medium.com/configuration-of-apache-web-server-in-docker-container-using-ansible-playbook-2157c2d1358b" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="7bc796067b0808f9138488ba6929abf2" data-thumbnail-img-id="1*O1GsvpMIIkgd0pw_-gglyQ.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*O1GsvpMIIkgd0pw_-gglyQ.png);"></a></div><ul class="postList"><li name="09e2" id="09e2" class="graf graf--li graf-after--mixtapeEmbed">IAM users should be created on AWS because Ansible requires an access key and secret key.</li><li name="51ef" id="51ef" class="graf graf--li graf-after--li">Key-pair that is to be attached with an instance should be present on the managed node.</li><li name="9bfd" id="9bfd" class="graf graf--li graf-after--li">Dynamic inventory should be set up for AWS EC2 instances</li></ul><p name="087d" id="087d" class="graf graf--p graf-after--li">If you are new to AWS do follow the below example for better understanding of AWS</p><div name="1638" id="1638" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://tiybok45.medium.com/create-high-availability-architecture-with-aws-cli-1fb3b643e59a" data-href="https://tiybok45.medium.com/create-high-availability-architecture-with-aws-cli-1fb3b643e59a" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://tiybok45.medium.com/create-high-availability-architecture-with-aws-cli-1fb3b643e59a"><strong class="markup--strong markup--mixtapeEmbed-strong">Create High Availability Architecture with AWS CLI</strong><br><em class="markup--em markup--mixtapeEmbed-em">The architecture includes webpage that is using EC2,EBC,S3,Cloud-Front for less latency and faster content delivery</em>tiybok45.medium.com</a><a href="https://tiybok45.medium.com/create-high-availability-architecture-with-aws-cli-1fb3b643e59a" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="f0452eb5eb44204926fc94ae82dbbb2c" data-thumbnail-img-id="1*QvuMQTxCs-tIfJXxa39Hsw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*QvuMQTxCs-tIfJXxa39Hsw.png);"></a></div><p name="1744" id="1744" class="graf graf--p graf-after--mixtapeEmbed">First of all, create one <strong class="markup--strong markup--p-strong">workspace</strong> for Ansible from where we will create all the roles. Also, put the <strong class="markup--strong markup--p-strong">ssh</strong> key inside the workspace and change the <strong class="markup--strong markup--p-strong">permission</strong> to 400.</p><figure name="faea" id="faea" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cil5V3FcAcNLdpWx30JE7A.png" data-width="1280" data-height="619" src="https://cdn-images-1.medium.com/max/800/1*cil5V3FcAcNLdpWx30JE7A.png"></figure><p name="8c41" id="8c41" class="graf graf--p graf-after--figure">Now create the <strong class="markup--strong markup--p-strong">configuration file</strong> of ansible in the workspace with these details.</p><figure name="98a6" id="98a6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*J43B6bF9QZCVWrxya-SjIw.png" data-width="1273" data-height="612" src="https://cdn-images-1.medium.com/max/800/1*J43B6bF9QZCVWrxya-SjIw.png"></figure><figure name="9a36" id="9a36" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*QV3mS2uCU7TuFWi3reRMyw.png" data-width="1278" data-height="625" src="https://cdn-images-1.medium.com/max/800/1*QV3mS2uCU7TuFWi3reRMyw.png"></figure><p name="6925" id="6925" class="graf graf--p graf-after--figure">Later we are going to use <strong class="markup--strong markup--p-strong">dynamic inventory</strong> concepts of Ansible to retrieve the IP Address of the EC2 instance so we need to put <strong class="markup--strong markup--p-strong">ec2.py</strong> and <strong class="markup--strong markup--p-strong">ec2.ini</strong> files inside the inventory directory. Also, make the ec2.py file executable. <strong class="markup--strong markup--p-strong">GitHub</strong> link for these two files are mentioned below:</p><pre name="9346" id="9346" class="graf graf--pre graf-after--p"><a href="https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory" data-href="https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory</a></pre><figure name="b871" id="b871" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*pghFdfhVgCDPF7IgdqJufA.png" data-width="1271" data-height="615" src="https://cdn-images-1.medium.com/max/800/1*pghFdfhVgCDPF7IgdqJufA.png"></figure><p name="377a" id="377a" class="graf graf--p graf-after--figure">The <strong class="markup--strong markup--p-strong">inventory/ec2.py</strong> script assumes that the environment variables needed for <strong class="markup--strong markup--p-strong">boto</strong> have already been set so before running we have to set the <strong class="markup--strong markup--p-strong">environmental variable</strong>.</p><pre name="686d" id="686d" class="graf graf--pre graf-after--p">export AWS_ACCESS_KEY_ID=&#39;RB123&#39;<br>export AWS_SECRET_ACCESS_KEY=&#39;asd123&#39;</pre><p name="b735" id="b735" class="graf graf--p graf-after--pre">The <strong class="markup--strong markup--p-strong">AWS credentials</strong> can optionally be specified inside the <strong class="markup--strong markup--p-strong">inventory/ec2.ini</strong> file Credentials specified here are ignored if the environment variables are set.</p><pre name="f98d" id="f98d" class="graf graf--pre graf-after--p">aws_access_key_id = AXXXXXXXXXXXXXX<br>aws_secret_access_key = XXXXXXXXXXXXXXXXXXX</pre><h3 name="345e" id="345e" class="graf graf--h3 graf-after--pre">Ansible role to launch AWS EC2 instances</h3><p name="8d94" id="8d94" class="graf graf--p graf-after--h3">Here I am going to create an Ansible role to launch three AWS EC2 instances. I am going to create the role inside the roles directory. <strong class="markup--strong markup--p-strong">ansible-galaxy</strong> is a command-line tool that comes bundled with Ansible, using which we can create a role with the <strong class="markup--strong markup--p-strong">init</strong> command.</p><pre name="a909" id="a909" class="graf graf--pre graf-after--p">ansible-galaxy role init kubernetes.instance</pre><figure name="d577" id="d577" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*Ej_K_XqdBI9jFxhuTxNgUA.png" data-width="1281" data-height="617" src="https://cdn-images-1.medium.com/max/800/1*Ej_K_XqdBI9jFxhuTxNgUA.png"></figure><p name="3e26" id="3e26" class="graf graf--p graf-after--figure">First, create all the variables in the <strong class="markup--strong markup--p-strong">vars/main.yml</strong> file which tasks will use to launch AWS EC2 instances.</p><pre name="0da7" id="0da7" class="graf graf--pre graf-after--p"># AWS Region Name# Amazon AMI ID # Instance type for instance # Subnet ID # Security group to attach with instance # key-pair for ssh into instance # Access &amp; secret key for IAM user<br>aws_region: ap-south-1 <br>aws_ami: ami-08f63db601b82ff5f <br>aws_instance_type: t2.micro <br>subnet_id: subnet-00566450d0ea4c288 <br>security_group_id: sg-7a400518 <br>key: ansible-key <br>access_key: AXXXXXXXXXXXXXX<br>secret_key: XXXXXXXXXXXXXXXXXXX</pre><p name="74d0" id="74d0" class="graf graf--p graf-after--pre">Now let’s create the task for launching instance inside the <strong class="markup--strong markup--p-strong">tasks/main.yml</strong> directory. Ansible has one module called <strong class="markup--strong markup--p-strong">ec2_instance</strong> using which we can launch instances on AWS.</p><pre name="42e3" id="42e3" class="graf graf--pre graf-after--p"><br># tasks file for kubernetes.instance<br>- name: Task to launch EC2 Instance<br> ec2_instance:<br> region: &quot;{{ aws_region }}&quot;<br> image_id: &quot;{{ aws_ami }}&quot;<br> instance_type: &quot;{{ aws_instance_type }}&quot;<br> vpc_subnet_id: &quot;{{ subnet_id }}&quot;<br> security_group: &quot;{{ security_group_id }}&quot;<br> key_name: &quot;{{ key }}&quot;<br> name: &quot;{{ item }}&quot;<br> state: present<br> aws_access_key: &quot;{{ access_key }}&quot;<br> aws_secret_key: &quot;{{ secret_key }}&quot;<br> loop: &quot;{{ name }}&quot;</pre><p name="1520" id="1520" class="graf graf--p graf-after--pre">Here I am using the <strong class="markup--strong markup--p-strong">loop</strong> as I want to launch three instances one for master and the other two for worker nodes and the name variable is a list so they will iterate the list and run this task three times for each value.</p><h3 name="f3c2" id="f3c2" class="graf graf--h3 graf-after--p">Ansible role to configure Kubernetes Master node</h3><p name="1ebe" id="1ebe" class="graf graf--p graf-after--h3">Now we will create an <strong class="markup--strong markup--p-strong">Ansible role</strong> that will configure one of the AWS EC2 instances as a K8s master node. So first we will create the role using the <strong class="markup--strong markup--p-strong">ansible-galaxy </strong>command.</p><pre name="e774" id="e774" class="graf graf--pre graf-after--p">ansible-galaxy role init kubernetes.master</pre><figure name="c4cb" id="c4cb" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*cv9REnQ33UBVMNzA2-7UgA.png" data-width="1277" data-height="608" src="https://cdn-images-1.medium.com/max/800/1*cv9REnQ33UBVMNzA2-7UgA.png"></figure><p name="8bf3" id="8bf3" class="graf graf--p graf-after--figure">First, create all the variables in the <strong class="markup--strong markup--p-strong">vars/main.yml</strong> file which will be used by tasks to configure the master node.</p><pre name="a070" id="a070" class="graf graf--pre graf-after--p"># Packages to be installed for Kubernetes<br>pkgs:<br>  - kubelet<br>  - kubectl<br>  - kubeadm<br>  - docker<br>  - iproute-tc</pre><pre name="ad42" id="ad42" class="graf graf--pre graf-after--pre"># Services to be started<br>services:<br>  - kubelet<br>  - docker</pre><pre name="4dc3" id="4dc3" class="graf graf--pre graf-after--pre"># Path for docker configuration directory<br>docker_daemon: &quot;/etc/docker/daemon.json&quot;</pre><pre name="575a" id="575a" class="graf graf--pre graf-after--pre"># Path for sysctl.d configuration directory<br>kubernetes_config: &quot;/etc/sysctl.d/k8s.conf&quot;</pre><p name="270e" id="270e" class="graf graf--p graf-after--pre">We require <strong class="markup--strong markup--p-strong">daemon.conf</strong> file and <strong class="markup--strong markup--p-strong">k8s.conf</strong> file to be present in files directory which will be used by tasks, <strong class="markup--strong markup--p-strong">files/daemon.conf</strong> file is for changing the default <strong class="markup--strong markup--p-strong">cgroup</strong> driver with <strong class="markup--strong markup--p-strong">systemd</strong>.</p><pre name="4543" id="4543" class="graf graf--pre graf-after--p">{<br> &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]<br>}</pre><p name="44fd" id="44fd" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">files/k8s.conf</strong> file to make sure that Master Node’s <strong class="markup--strong markup--p-strong">iptables</strong> can correctly see bridged traffic so we have to ensure <strong class="markup--strong markup--p-strong">net.bridge.bridge-nf-call-iptables</strong> is set to 1 in the <strong class="markup--strong markup--p-strong">sysctl</strong> config.</p><pre name="60df" id="60df" class="graf graf--pre graf-after--p">net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1</pre><p name="4f93" id="4f93" class="graf graf--p graf-after--pre">Now we will create Ansible <strong class="markup--strong markup--p-strong">tasks</strong> inside the tasks/main.yml file which will configure the master node. We have to use the <strong class="markup--strong markup--p-strong">add_host</strong> module to create one <strong class="markup--strong markup--p-strong">dummy host group</strong> so that we can store the <strong class="markup--strong markup--p-strong">join</strong> command inside it which will be used by the worker node to join.</p><pre name="04a8" id="04a8" class="graf graf--pre graf-after--p"># tasks file for kubernetes.master</pre><pre name="76da" id="76da" class="graf graf--pre graf-after--pre">- name: Configure yum repo for Kubernetes<br>  yum_repository:<br>    name: kubernetes<br>    baseurl: <a href="https://packages.cloud.google.com/yum/repos/kubernetes-el7-/$basearch" data-href="https://packages.cloud.google.com/yum/repos/kubernetes-el7-/$basearch" class="markup--anchor markup--pre-anchor" rel="noopener ugc nofollow noopener" target="_blank">https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</a><br>    enabled: yes<br>    gpgcheck: yes<br>    repo_gpgcheck: yes<br>    gpgkey: <br>      - <a href="https://packages.cloud.google.com/yum/doc/yum-key.gpg" data-href="https://packages.cloud.google.com/yum/doc/yum-key.gpg" class="markup--anchor markup--pre-anchor" rel="noopener ugc nofollow noopener" target="_blank">https://packages.cloud.google.com/yum/doc/yum-key.gpg</a><br>      - <a href="https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg" data-href="https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg" class="markup--anchor markup--pre-anchor" rel="noopener ugc nofollow noopener" target="_blank">https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</a><br>    description: &quot;Yum repository for Kubernetes&quot;</pre><pre name="a9fa" id="a9fa" class="graf graf--pre graf-after--pre">- name: Install required packages<br>  yum:<br>    name: &quot;{{ item }}&quot;<br>    state: present<br>  loop: &quot;{{ pkgs }}&quot;</pre><pre name="c98f" id="c98f" class="graf graf--pre graf-after--pre">- name: Start and enable kubelet<br>  service:<br>    name: &quot;{{ item }}&quot;<br>    state: started<br>    enabled: yes<br>  loop: &quot;{{ services }}&quot;<br>  register: svc_start</pre><pre name="38bf" id="38bf" class="graf graf--pre graf-after--pre">- name: Docker config image<br>  shell:<br>    cmd: &quot;kubeadm config images pull&quot;<br>  when: svc_start.changed</pre><pre name="5fca" id="5fca" class="graf graf--pre graf-after--pre">- name: Change docker cgroup<br>  copy:<br>    dest: &quot;{{ docker_daemon }}&quot;<br>    src: daemon.json<br>  notify: restart docker</pre><pre name="27d7" id="27d7" class="graf graf--pre graf-after--pre">- name: Force handler to execute<br>  meta: flush_handlers</pre><pre name="2e78" id="2e78" class="graf graf--pre graf-after--pre">- name: Copy k8s.conf file to master<br>  copy:<br>    src: k8s.conf<br>    dest: &quot;{{ kubernetes_config }}&quot;<br>  register: result</pre><pre name="407e" id="407e" class="graf graf--pre graf-after--pre">- name: Load settings from all system configuration files<br>  shell:<br>    cmd: sysctl --system<br>  when: result.changed</pre><pre name="0df8" id="0df8" class="graf graf--pre graf-after--pre">- name: Start the kubernetes master<br>  shell:<br>    cmd: &quot;kubeadm init --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors=NumCPU --ignore-preflight-errors=Mem&quot;<br>  when: result.changed</pre><pre name="6010" id="6010" class="graf graf--pre graf-after--pre">- name: Create folder for kube<br>  file:<br>    path: $HOME/.kube<br>    state: directory<br>  register: kube_dir</pre><pre name="8957" id="8957" class="graf graf--pre graf-after--pre">- name: Copy admin.conf file to kube<br>  copy:<br>    src: &quot;/etc/kubernetes/admin.conf&quot;<br>    dest: &quot;$HOME/.kube/config&quot;<br>    owner: &quot;{{ kube_dir.owner }}&quot;<br>    group: &quot;{{ kube_dir.group }}&quot;<br>    remote_src: yes<br>  when: kube_dir.changed</pre><pre name="895b" id="895b" class="graf graf--pre graf-after--pre">- name: Get join command<br>  shell:<br>    cmd: &quot;kubeadm token create --print-join-command&quot;<br>  register: output</pre><pre name="8641" id="8641" class="graf graf--pre graf-after--pre">- name: &quot;Dummy host to register join command&quot;<br>  add_host:<br>    name: Dummy_Host<br>    join_cmd: &quot;{{ output.stdout }}&quot;<br>  when: output.changed- name: Setup flannel network<br>  command: &quot;kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml&quot;<br>  when: result.changed</pre><p name="ce3a" id="ce3a" class="graf graf--p graf-after--pre">As <strong class="markup--strong markup--p-strong">“Change docker cgroup” </strong>so we will have to create a handler inside the <strong class="markup--strong markup--p-strong">handlers/main.yml</strong> file which will restart the docker service after changing the cgroup drive to systemd.</p><pre name="7831" id="7831" class="graf graf--pre graf-after--p"># handlers file for kubernetes.master<br>- name: restart docker<br>  service:<br>    name: &quot;{{ services[1] }}&quot;<br>    state: restarted</pre><h3 name="0d7e" id="0d7e" class="graf graf--h3 graf-after--pre">Ansible role to configure Kubernetes Worker node</h3><p name="39c1" id="39c1" class="graf graf--p graf-after--h3">Now we will create an <strong class="markup--strong markup--p-strong">Ansible role</strong> that will configure two of the AWS EC2 instances as a K8s worker node. So first we will create the role using the <strong class="markup--strong markup--p-strong">ansible-galaxy</strong> command.</p><pre name="b53f" id="b53f" class="graf graf--pre graf-after--p">ansible-galaxy role init kubernetes.worker</pre><figure name="4f6a" id="4f6a" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*FuCF0PQrAD3HCMyD1hg--Q.png" data-width="1277" data-height="619" src="https://cdn-images-1.medium.com/max/800/1*FuCF0PQrAD3HCMyD1hg--Q.png"></figure><p name="6602" id="6602" class="graf graf--p graf-after--figure">First, create all the variables in the <strong class="markup--strong markup--p-strong">vars/main.yml</strong> file which will be used by tasks to configure the worker nodes.</p><pre name="862b" id="862b" class="graf graf--pre graf-after--p"># Packages to be installed for Kubernetes<br>pkgs:<br>  - kubelet<br>  - kubectl<br>  - kubeadm<br>  - docker<br>  - iproute-tc</pre><pre name="9e17" id="9e17" class="graf graf--pre graf-after--pre"># Services to be started<br>services:<br>  - kubelet<br>  - docker</pre><pre name="3006" id="3006" class="graf graf--pre graf-after--pre"># Path for docker configuration directory<br>docker_daemon: &quot;/etc/docker/daemon.json&quot;</pre><pre name="ce63" id="ce63" class="graf graf--pre graf-after--pre"># Path for sysctl.d configuration directory<br>kubernetes_config: &quot;/etc/sysctl.d/k8s.conf&quot;</pre><p name="a815" id="a815" class="graf graf--p graf-after--pre">We require <strong class="markup--strong markup--p-strong">daemon.conf</strong> file and <strong class="markup--strong markup--p-strong">k8s.conf</strong> file to be present in files directory which will be used by tasks, <strong class="markup--strong markup--p-strong">files/daemon.conf</strong> file is for changing the default <strong class="markup--strong markup--p-strong">cgroup</strong> driver with <strong class="markup--strong markup--p-strong">systemd</strong>.</p><pre name="17d8" id="17d8" class="graf graf--pre graf-after--p">{<br> &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]<br>}</pre><p name="d726" id="d726" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">files/k8s.conf</strong> file to make sure that Worker Node’s <strong class="markup--strong markup--p-strong">iptables</strong> can correctly see bridged traffic so we have to ensure <strong class="markup--strong markup--p-strong">net.bridge.bridge-nf-call-iptables</strong> is set to 1 in the <strong class="markup--strong markup--p-strong">sysctl</strong> config.</p><pre name="680a" id="680a" class="graf graf--pre graf-after--p">net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1</pre><p name="d14a" id="d14a" class="graf graf--p graf-after--pre">Now we will create Ansible tasks inside the <strong class="markup--strong markup--p-strong">tasks/main.yml</strong> file which will configure the worker nodes. Here we will use a <strong class="markup--strong markup--p-strong">dummy host</strong> to get the <strong class="markup--strong markup--p-strong">join</strong>command using which worker node will <strong class="markup--strong markup--p-strong">register</strong> themself to the master node.</p><pre name="e702" id="e702" class="graf graf--pre graf-after--p"># tasks file for kubernetes.worker</pre><pre name="80e0" id="80e0" class="graf graf--pre graf-after--pre">- name: Configure yum repo for Kubernetes<br>  yum_repository:<br>    name: kubernetes<br>    baseurl: <a href="https://packages.cloud.google.com/yum/repos/kubernetes-el7-/$basearch" data-href="https://packages.cloud.google.com/yum/repos/kubernetes-el7-/$basearch" class="markup--anchor markup--pre-anchor" rel="noopener ugc nofollow noopener" target="_blank">https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</a><br>    enabled: yes<br>    gpgcheck: yes<br>    repo_gpgcheck: yes<br>    gpgkey:<br>      - <a href="https://packages.cloud.google.com/yum/doc/yum-key.gpg" data-href="https://packages.cloud.google.com/yum/doc/yum-key.gpg" class="markup--anchor markup--pre-anchor" rel="noopener ugc nofollow noopener" target="_blank">https://packages.cloud.google.com/yum/doc/yum-key.gpg</a><br>      - <a href="https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg" data-href="https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg" class="markup--anchor markup--pre-anchor" rel="noopener ugc nofollow noopener" target="_blank">https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</a><br>    description: &quot;Yum repository for Kubernetes&quot;</pre><pre name="5578" id="5578" class="graf graf--pre graf-after--pre">- name: Install required packages<br>  yum:<br>    name: &quot;{{ item }}&quot;<br>    state: present<br>  loop: &quot;{{ pkgs }}&quot;</pre><pre name="7dd7" id="7dd7" class="graf graf--pre graf-after--pre">- name: Start and enable kubelet<br>  service:<br>    name: &quot;{{ item }}&quot;<br>    state: started<br>    enabled: yes<br>  loop: &quot;{{ services }}&quot;<br>  register: svc_start</pre><pre name="2f58" id="2f58" class="graf graf--pre graf-after--pre">- name: Change docker cgroup<br>  copy:<br>    dest: &quot;{{ docker_daemon }}&quot;<br>    src: daemon.json<br>  when: svc_start.changed<br>  notify: restart docker- name: Force handler to execute<br>  meta: flush_handlers</pre><pre name="5bfb" id="5bfb" class="graf graf--pre graf-after--pre">- name: Copy k8s.conf file to worker<br>  copy:<br>    src: k8s.conf<br>    dest: &quot;{{ kubernetes_config }}&quot;<br>  register: result</pre><pre name="2b68" id="2b68" class="graf graf--pre graf-after--pre">- name: Load settings from all system configuration files<br>  shell: sysctl --system<br>  when: result.changed</pre><pre name="86f1" id="86f1" class="graf graf--pre graf-after--pre">- name: &quot;Join the worker to master&quot;<br>  command: &quot;{{ hostvars.Dummy_Host.join_cmd }}&quot;<br>  when: result.changed</pre><p name="66f1" id="66f1" class="graf graf--p graf-after--pre">As <strong class="markup--strong markup--p-strong">“Change docker cgroup” </strong>so we will have to create a handler inside the <strong class="markup--strong markup--p-strong">handlers/main.yml</strong> file which will restart the docker service after changing the cgroup drive to systemd.</p><pre name="6b06" id="6b06" class="graf graf--pre graf-after--p"># handlers file for kubernetes.master<br>- name: restart docker<br>  service:<br>    name: &quot;{{ services[1] }}&quot;<br>    state: restarted</pre><h3 name="78d2" id="78d2" class="graf graf--h3 graf-after--pre">Create Playbook to use the role</h3><p name="e3b0" id="e3b0" class="graf graf--p graf-after--h3">As our role is created so now we will create one playbook to run the roles. I am creating the playbook inside the workspace named <strong class="markup--strong markup--p-strong">setup.yml</strong>.</p><pre name="beb1" id="beb1" class="graf graf--pre graf-after--p">- hosts: localhost<br>  roles:<br>    - kubernetes.instance<br>  tasks:<br>    - meta: refresh_inventory</pre><pre name="0f83" id="0f83" class="graf graf--pre graf-after--pre">- hosts: tag_Name_K8S_Master<br>  roles:<br>    - kubernetes.master</pre><pre name="367d" id="367d" class="graf graf--pre graf-after--pre">- hosts: tag_Name_K8S_Worker1<br>  roles:<br>    - kubernetes.worker</pre><pre name="dfb1" id="dfb1" class="graf graf--pre graf-after--pre">- hosts: tag_Name_K8S_Worker2<br>  roles:<br>    - kubernetes.worker</pre><p name="0056" id="0056" class="graf graf--p graf-after--pre">Here we have to use <strong class="markup--strong markup--p-strong">refresh_inventory</strong> so that inventory will be refreshed while running. Now finally run the playbook to configure the Kubernetes cluster on AWS.</p><figure name="e258" id="e258" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OxxSow0kHgPu1fHQL-JfnA.png" data-width="1279" data-height="619" src="https://cdn-images-1.medium.com/max/800/1*OxxSow0kHgPu1fHQL-JfnA.png"></figure><pre name="65d5" id="65d5" class="graf graf--pre graf-after--figure">ansible-playbook setup.yml</pre><figure name="42d0" id="42d0" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*b2nDCEZItuKvSvGo9E-V8A.png" data-width="1282" data-height="626" src="https://cdn-images-1.medium.com/max/800/1*b2nDCEZItuKvSvGo9E-V8A.png"></figure><figure name="cc07" id="cc07" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*hrkE-yDjSMu1Vxh0GpgGdQ.png" data-width="1381" data-height="289" src="https://cdn-images-1.medium.com/max/800/1*hrkE-yDjSMu1Vxh0GpgGdQ.png"></figure><p name="6e1a" id="6e1a" class="graf graf--p graf-after--figure">Here we can see that three instances have been launched with the name as <strong class="markup--strong markup--p-strong">K8S_Master, K8S_Worker1 &amp; K8S_Worker1</strong>. Now let’s see the status of the cluster.</p><figure name="47df" id="47df" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MnXx5jTcfVygOkSGq2Mupw.png" data-width="1375" data-height="514" src="https://cdn-images-1.medium.com/max/800/1*MnXx5jTcfVygOkSGq2Mupw.png"></figure><p name="0e09" id="0e09" class="graf graf--p graf-after--figure">Now let’s create one pod with an <strong class="markup--strong markup--p-strong">application</strong> to test the k8s cluster. Here I am going to create the <strong class="markup--strong markup--p-strong">deployment</strong> using the <strong class="markup--strong markup--p-strong">httpd</strong> image which is pre-configured with the <strong class="markup--strong markup--p-strong">webserver</strong>.</p><figure name="dc19" id="dc19" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*m4gMUSVRBiVpF96QXGSe_Q.png" data-width="1356" data-height="309" src="https://cdn-images-1.medium.com/max/800/1*m4gMUSVRBiVpF96QXGSe_Q.png"></figure><p name="9480" id="9480" class="graf graf--p graf-after--figure">Now I am going to <strong class="markup--strong markup--p-strong">expose</strong> the pod so that we can access it from outside so I am creating a <strong class="markup--strong markup--p-strong">NodePort</strong> service.</p><figure name="0edf" id="0edf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jFnpNE5BCJtH1ubuonIVPg.png" data-width="1375" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*jFnpNE5BCJtH1ubuonIVPg.png"></figure><p name="190c" id="190c" class="graf graf--p graf-after--figure">Now we can access the application with any of the cluster node’s public IP addresses on the 30053 port number.</p><p name="eecc" id="eecc" class="graf graf--p graf-after--p graf--trailing">Kubernetes multi-node cluster is configured and working great now we can use it for deploying any <strong class="markup--strong markup--p-strong">containerized applications</strong>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@tiybok45" class="p-author h-card">Rutvik Bhalerao</a> on <a href="https://medium.com/p/8eae81180254"><time class="dt-published" datetime="2022-01-17T15:28:24.000Z">January 17, 2022</time></a>.</p><p><a href="https://medium.com/@tiybok45/ansible-role-to-configure-k8s-multi-node-cluster-over-aws-cloud-8eae81180254" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 22, 2022.</p></footer></article></body></html>